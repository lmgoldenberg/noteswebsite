<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS Notes</title>
  </head>
  <body>
    <main>
        <h1 id="memory-management">Memory Management</h1>
<h2 id="3-1-introduction-to-process-image">3.1 Introduction to Process Image</h2>
<p>When C code is compiled, it is translated into assembly code, which includes variables and instructions that are sorted in the virtual memory (382!). (See 3.1 below for refresher)</p>
<p>The virtual memory (VM) address starts at <code>0x0</code> to a large number, on a 32-bit machine, the VM size is always 4GB: 3GB for the user addressable portion, and 1 GB for the kernel addressable portion.</p>
<p>The lowest address of <code>0x0</code> to a random small address is unused for security reasons.</p>
        <img src="./images3923/1.png" alt="img id 1, if you see this msg email me!">
<p><strong>Read-Only Segment</strong></p>
<p>The read-only segment contains the second lowest address space in the VM, and contains the <code>.text</code> and <code>.rodata</code> segments.
<code>.text</code>: binary machine code (translated from our C code) is stored, for example function pointers to here</p>
<p><code>.rodata</code> stores read-only data, which are primarily string literals</p>
<p>Take a look at these 2 ways to declare a string</p>
<pre><code class="lang-C">char str1[] = <span class="hljs-string">"abc"</span><span class="hljs-comment">;</span>
char* str2 = <span class="hljs-string">"def"</span><span class="hljs-comment">;</span>
</code></pre>
<p>The 4 chars <code>&quot;abc&quot;</code>, yes 4 because null terminator, will be placed on the local stack if in a function, or <code>.data</code> if declared globally, while <code>&quot;def&quot;</code>, will always be in the <code>.rodata</code> segment.</p>
<p>Data on the stack is mutable, data in <code>.rodata</code>, as the name read only data implies, is not.</p>
<p>This means <code>str1[0] = &#39;A&#39;</code> is okay, but <code>str2[0] = &#39;D&#39;</code> is not.</p>
<p><strong>Read/Write Segment</strong></p>
<p>Next up is the read/write segment (r/w), including <code>.data</code> and <code>.bss</code>(Block Started by Symbol), global variables that do not belong to any function will be placed in the <code>.data</code> segement if initialized, otherwise <code>.bss</code></p>
<p><strong>Heap</strong></p>
<p>Above the r/w segement is the heap, which grows upwards. It is managed by us, and is dynamically allocated. If in our code we want to allocate new spaces somewhere, it is allocated in the heap, and once we are done using the space we must manually release it.</p>
<p><strong>Stack</strong></p>
<p>Stack is managed by the compiler, and contains local variables, function parameters, function returning address, etc, the stack grows downwards and is automatically prepared by the compiler, static allocation happens here.</p>
<h2 id="heap-management">Heap Management</h2>
<p>The figure in 3.1 (see above) shows a basic layout, the read-only r/w segments are loaded from our executable file, and the rest of the VM will be used when the process is executing.</p>
<p>The stack area is managed by <strong>static allocation</strong> during <strong>compilation time</strong></p>
<p>Last semester we have seen why this is static from our assembly code.</p>
<p>Operations such as load/store from/to the stack, and change stack pointer <code>SP</code>, in our assembly code. During runtime the stack will grow or shrink as we programming, and therefore it can&#39;t be freed from memory until the process finishes.</p>
<p>Many times we have no idea how much memory we need when writing code, for example if the size of an array is determined by user input when running a program. In these cases we resort to <strong>dynamic allocation</strong> which happens during <strong>run time</strong></p>
<p>The lowest portion of the process image contains the read-only and r/w segments that are loaded from the executable, the end of the r/w segment is the start of the heap, and that point is called the <strong>program break</strong>* See 3.2 below for visualization</p>
<p>* often the program break is actually the nearest end of the page that contains the r/w segment, not the point where the r/w segment ends.</p>
<p>These 2 functions change the top of the heap</p>
<pre><code class="lang-C"> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* addr)</span></span>;
 <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;
</code></pre>
<p><code>brk()</code> is a system call that changes the program break to a memory location <code>addr</code>, it&#39;s return value is either a success (0), or failure (-1). 
<code>sbrk()</code> will increment the current program break by <code>increment</code> bytes, and returns the previous program break (before increment), it is a C library function that calls <code>brk()</code>.</p>
<p>You can see the current program break by calling <code>sbrk(0)</code>. (no increment, no change, still returns value)</p>
<p>The space between the end of r/w and the program break is the <strong>heap</strong>, managing the heap using <code>sbrk()</code> and <code>brk()</code> is poor practice, but these concepts are important for other functions like  <code>malloc()</code></p>
        <img src="./images3923/2.png" alt="img id 2, if you see this msg email me!">
        <p><strong>Using C Library Calls</strong></p>
<p>To allocate new space in memory manually, it is better to use <code>malloc()</code> which is declared in <code>&lt;stdlib.h&gt;</code>,</p>
<p>Here is an example of using <code>malloc()</code></p>
<pre><code class="lang-C"><span class="hljs-comment">/*** usemalloc.c ***/</span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">int</span>* ptr = (<span class="hljs-keyword">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
   (*ptr) = <span class="hljs-number">252</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }
</code></pre>
<p><code>malloc()</code> takes in the size to allocate as its argument in bytes, using <code>sizeof()</code> will return the number in bytes so its very convenient.
<code>malloc()</code> also returns a type <code>void*</code>, but can be casted to a different pointer type.</p>
<p>Here is an example of allocating an array with 10 elements, notice the sizeof is multiplied by 10 to account for 10 integers.
<code>int* ptr = (int*) malloc(sizeof(int) * 10);</code></p>
<p>Make sure to add 1 to the number of bytes when using <code>malloc()</code> for strings using <code>strlen()</code> to account for the null terminator. You do not need to do this with <code>sizeof()</code></p>
<p><strong>Initialization</strong></p>
<p>The system will determine where in the heap to place the dynamically allocated block from <code>malloc()</code>, and it might reuse space that was previously allocated and freed. When a block is freed, the system marks it as reusable <strong>without</strong> clearing it&#39;s data, which can cause problems.</p>
<p>One way to avoid this is to use <code>memset()</code> after <code>malloc()</code> to set all bytes in an address range to 0. See example below</p>
<pre><code class="lang-C">struct Rectangle* r = malloc( <span class="hljs-name">sizeof</span>(<span class="hljs-name">struct</span> Rectangle) )<span class="hljs-comment">;</span>
 memset(<span class="hljs-name">r</span>, <span class="hljs-number">0</span>, sizeof(<span class="hljs-name">struct</span> Rectangle))<span class="hljs-comment">;</span>
</code></pre>
<p>This sets all bytes from <code>r</code> to <code>sizeof(struct Rectangle)</code>  to <code>0</code>s.</p>
<p>Another way is to use <code>calloc()</code></p>
<pre><code class="lang-C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
 <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> nelem, <span class="hljs-keyword">size_t</span> elsize)</span></span>;
</code></pre>
<p>where a region of size <code>nelem</code>x<code>elsize</code> will be allocated on the heap, set to 0, and have the starting address returned.</p>
<p>Here is an example of allocating space for 10 ints like the <code>malloc()</code> example above 
<code>int* ptr_array = calloc(10, sizeof(int));</code></p>
<p><strong>Program Break and <code>malloc()</code></strong></p>
<p>the <code>malloc()</code> function calls system call  <code>brk()</code> to allocate space.</p>
<p>Here is an example</p>
<pre><code class="lang-C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
 <span class="hljs-keyword">void</span>* curr_top = sbrk(<span class="hljs-number">0</span>);
 <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);
 <span class="hljs-keyword">void</span>* new_top = sbrk(<span class="hljs-number">0</span>);
 <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p &lt;- before malloc(100)\n%p &lt;- after malloc(100)\n"</span>, curr_top, new_top);
}
</code></pre>
<p>The output will be </p>
<pre><code> <span class="hljs-number">0xaaaaf6187000</span> &lt;- <span class="hljs-keyword">before</span> <span class="hljs-title">malloc</span>(100)
 <span class="hljs-number">0xaaaaf61a8000</span> &lt;- <span class="hljs-keyword">after</span> <span class="hljs-title">malloc</span>(100)
</code></pre><p>The program break increased by <code>0x21000</code> bytes instead of just 100 bytes, this is because <code>malloc()</code> will first search to see if there is space available under the program break*, if not then it will call <code>sbrk()</code> to allocate more space, usually in multiples of the virtual page size. Since a typical virtual page is 4KB, which is <code>0x1000</code> bytes, <code>0x21000</code> is a multiple of the page size. See 3.3 below for an example.</p>
<p>*unlike the stack where space below the stack top is all occupied, the heap can be either occupied or unoccupied.</p>
<p>The lifetime of statically allocated variables depends on the scope it is defined. If it is an array in a function, then the array dies when the function dies. This is managed by the compiler or the program. Since in dynamic allocation it is us who allocated the space, we must also release it. To do use use <code>free()</code> as seen below</p>
<pre><code class="lang-C">int* ptr_integer = (<span class="hljs-name">int*</span>) malloc(<span class="hljs-name">sizeof</span>(<span class="hljs-name">int</span>))<span class="hljs-comment">;</span>
free(<span class="hljs-name">ptr_integer</span>)<span class="hljs-comment">;</span>
int* ptr_array = (<span class="hljs-name">int*</span>) malloc(<span class="hljs-name">sizeof</span>(<span class="hljs-name">int</span>) * 10);
free(ptr_array);
</code></pre>
        <img src="./images3923/3.png" alt="img id 3, if you see this msg email me!">
        <p><strong>Implementing Memory Allocator</strong></p>
<p>There are two types of memory allocators, explicit and implicit. <strong>Explicit allocators</strong> are used by C and C++ where spaces are manually allocated using <code>malloc()</code> or the <code>new</code> keyword. <strong>Implicit allocators</strong> which can be found in JAVA, the programmer doesn&#39;t have to manually allocate space. This course will foocus on explicit allocation and specifically <code>malloc()</code></p>
<p>When using <code>free()</code> only a pointer returned by <code>malloc()</code> needs to be passed. This means the system knows how many bytes to free without knowing the size.</p>
<p>note chunks and blocks mean the same thing, I(Lewis) will write notes using blocks only but if you see chunks its just blocks.</p>
<p><strong>Blocks allocated by <code>malloc()</code></strong></p>
<p>The basic structure of each block is allocated by <code>malloc()</code> is shown in 3.4 below. </p>
<p>The block starts with an 8-byte header which contains the <code>size</code> variable which records the size of the allocated block. Since the block size is always multiples of 8 bytes, the least significant bit is used to indicate if the block is in use or not. (1 for use, 0 for free)</p>
<p>Next is the actual space the user can use, it&#39;s starting address is returned by <code>malloc()</code>, and is called the <strong>payload</strong>. Due to how linux functions, all blocks should start from multiples of 16, so there may be some extra space of 0s called padding. 
The minimal size of a block is 4*<code>sizeof(void*)</code> which on a 64-bit machine, is usually 32 bytes. (a pointer is 8 bytes)</p>
        <img src="./images3923/4.png" alt="img id 4, if you see this msg email me!">
<p>Let us look at this example</p>
<pre><code class="lang-C"> <span class="hljs-comment">/*** mallocblock.c ***/</span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
 <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>* p_payload = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);
 <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>* p_header = p_payload- <span class="hljs-number">1</span>;
 <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%ld\n"</span>, *p_header);
 <span class="hljs-built_in">free</span>(p_payload);
 <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%ld\n"</span>, *p_header);
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }
</code></pre>
<p><code>long int*</code> is 8 bytes, which is the size of the header. The first line in the output is 33, so the block allocated contains 32 bytes. 8 for header, and 1 requested through <code>malloc()</code> (see 3.5 below), 23 padding. It shows 33 because the least significant bit of the header is 1, which indicates the space is being used. Once the space is freed, it will print 32.</p>
<p>After <code>malloc()</code> and <code>free()</code> is used a block may look like 3.6 (see below), where free and allocated blocks are mixed together. If we are to call <code>malloc()</code> it will iterate over the entire heap to find a free block larger than the requested size. This is done through a linked list of blocks called a <strong>free list</strong>, in C a double linked list called <strong>explicit free list</strong> is used.</p>
<p>Figure 3.7 (see below) shows what a block looks like when freed. The header still records the size, but the in-use flag will be turned off, and the first 8 bytes become a pointer pointing to the previous freed block in the free list, and the next 8 bytes will point to the next freed block in the free list. The rest will stay untouched. </p>
<p>Even if we call <code>free()</code>, the space is still accessible, but the data might be overwritten by pointers used by the system, the rest of the data will either be untouched or changed to 0s. </p>
<p>Just because we can still access (read and write) to the data in the free&#39;d chunk, we should not do so, since it is very likely to cause a segmentation fault.</p>
        <img src="./images3923/5.png" alt="img id 5, if you see this msg email me!">
        <img src="./images3923/6.png" alt="img id 6, if you see this msg email me!">
        <img src="./images3923/7.png" alt="img id 7, if you see this msg email me!">
<p>When adding a free block to the free list, we need to consider the location of the block in relation to other blocks.</p>
<p>This can be done by using the memory address of each block by traversing the free list. Since we always follow the physical location, we are using the benefits of locality.</p>
<p>This can also be done through LIFO, which can be faster since we don&#39;t have to traverse the free list, this can be done by always adding the newly freed block to the front of the list, regardless of it&#39;s location in memory. This is O(1) time.</p>
<p>This can also be done through block size, the advantage here is to use the memory efficiently since we don&#39;t care for it&#39;s location, only it&#39;s size, so we can always find the one that closest fits our <code>malloc()</code> call, but it also requires a list traversal.</p>
<p>To reuse a free chunk for <code>malloc()</code>, the double linked list must be traversed to find a block with a large enough size. It is possible that we allocated a lot of small blocks and freed them all. This would cause <code>malloc()</code> to be unable to find a larger block if needed. This problem is called <strong>external fragmentation</strong>, it&#39;s solution is <strong>coalescing</strong>, which is to merge adjacent freed blocks into 1 large block.</p>
<p>Coalescing can be done when freeing a block, by checking whether it is next to other freed blocks, and if so merge them. This is called <strong>Immedieate Coalescing</strong></p>
<p>Coalescing can also be done when searching for a freed block, and we end up finding two blocks located next to each other in memory, and then merging them together. This is called <strong>Deferred Coalescing</strong></p>

    </main>
  </body>
</html>