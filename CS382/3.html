<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS Notes</title>
  </head>
  <body>
    <main>
        <h1 id="microprocessor-design">Microprocessor Design</h1>
<p>Made up of registers and the arithmetic logic unit (ALU)
is able to store data temporarily and perform arithmetic calculations</p>
<h2 id="3-1-logic-gates">3.1 Logic Gates</h2>
<p>4 logic gates: and, or, xor/exclusive or, not</p>
<p>the delay between the change in inputs and the result becoming <code>1</code> is the <strong>rising delay</strong></p>
<p>the delay between  the change in inputs and the output becoming <code>0</code> is the <strong>falling delay</strong></p>
        <img src="./images3823/1.png" alt="">
        <img src="./images3823/2.png" alt="">
        <h3 id="3-1-2-combinational-logic">3.1.2 Combinational Logic</h3>
<p><strong>Combinational logic</strong> is when logic gates are combined in one direction with no loops</p>
<p>Checking if two different bits are equal is easy, however to check if two larger data types (ex: double words) are equal, you must use <strong>buses</strong> in order to easily transfer data from one input into multiple logic gates that check each bit individually. </p>
<p>To select which input you want to use as an output, use a <strong>multiplexer (MUX)</strong>.
To make a bit multiplexer, there must be 3 inputs, <code>a</code>, <code>b</code>, and <code>s</code> which is the <strong>control signal</strong></p>
<p>The control signal is a switch that controls which input is selected between the two. 
When the control signal is <code>1</code> the signal is <strong>asserted/set</strong>
When the control signal is  <code>0</code> the signal is <strong>deasserted/clear</strong></p>
<p>To choose between multiple inputs, you need a <strong>N-Way multiplexer</strong>, where N is the amount of inputs you are choosing between.</p>
<p>To figure out how may control signals you need for a multiplexer, use <code>S = round_up(log_2 N)</code>, easy way is how many bits you need to represent your number of choices in binary.</p>
<p>Performing arithmetic uses combinational logic.</p>
<p>To add 2 bits, there must be 2 inputs <code>x</code> and <code>y</code>, and as well as a <strong>carry-in flag</strong> <code>cin</code>.
The output will also require a <strong>carry-out flag</strong> <code>cout</code></p>
<p>This is effectively allowing you to add up to 3 numbers, truth table attached below. This is important when adding larger values.</p>
<p>The smallest carry out flag will usually be <code>0</code>, and the largest carry-out flag will be sent to the CSPR&#39;s carry flag.</p>
<img src="./images3823/3.png" alt="">
<h3 id="3-1-3-sequential-logic">3.1.3 Sequential Logic</h3>
<p>Used to store data</p>
<p>A <strong>bistable element</strong> does not have any cycles and has two outputs, <code>p</code> and <code>q</code>, and an input <code>in</code>.</p>
<p>When <code>in</code> goes from <code>0</code> to  <code>1</code> then <code>0</code> shortly after, both <code>p</code> and <code>q</code> take a small delay to respond, and then shortly change back to their original state. This is combinational logic</p>
<p>To make sure that <code>p</code> and <code>q</code> save their results from <code>in</code> being turned in, you must add a loop between <code>q</code> and the wire of <code>in</code>. This changes the logic from combinational to sequential. </p>
<p>The reason why this works is because when you set <code>q</code> to <code>1</code> and <code>p</code> to <code>0</code> using <code>in</code>, <code>q</code> will send the value back to the wire of <code>in</code>, this will cause a loop where <code>in</code> is powering <code>p</code> and <code>q</code>, and <code>q</code> is powering the wire of <code>in</code> which is connected to <code>p</code> and <code>q</code>. See attached for more detail.</p>
<p>Sequential logic has a higher delay than combinational logic, this delay is called <strong>propogation delay</strong>.</p>
<p>A flaw with the bistable element is that it is impossible to switch the outputs back to their original state.</p>
<img src="./images3823/4.png" alt="">
<p><strong>Set-Reset latches (SR latch</strong> are a type of circuit that allows you to change the output back to it&#39;s original state. </p>
<p>There are 2 inputs, <code>S(set)</code>, <code>R(reset)</code>, and 2 outputs <code>Q+</code> and <code>Q-</code>.</p>
<p><code>Q+</code> and <code>Q-</code> will always have opposite values.</p>
<p>Setting <code>S</code> to <code>1</code>, then <code>0</code> shortly after will cause the output <code>Q+</code> to change to <code>1</code>.</p>
<p>To change <code>Q+</code> back to <code>0</code>, change <code>R</code> to <code>1</code> then back to <code>0</code>. </p>
<p>SR latches have 4 possible states. (See truth table attached)
Setting: make <code>S</code> <code>1</code>, causing <code>Q+</code> to become <code>1</code>
Resetting: make <code>R</code> <code>1</code>, causing <code>Q+</code> to revert to <code>0</code>)
Latched/Stored: The input of <code>S</code> or <code>R</code> are both <code>0</code>, and the values of <code>Q</code> and <code>R</code> depend on the previous state.
Metastable: Both <code>S</code> and <code>R</code> are <code>1</code>, causing an error.</p>
<p>The truth table for an SR latch is written using <code>q</code> to determine the value of <code>Q+</code> and <code>!q</code> is used to determine the value of <code>Q-</code></p>
<p>The SR latch is only good for sending 1 bit, and not actual data. This is because it is hard to sync multiple of them when trying to handle larger data types.</p>
<img src="./images3823/5.png" alt="">
<img src="./images3823/6.png" alt="">
<p>The <strong>Data Latch (D Latch)</strong> solves the two flaws of the SR latch</p>
<ol>
<li><code>S</code> and <code>R</code> are unable to store actial data</li>
<li>When there are many SR latches, it is difficult to synchronize them.</li>
</ol>
<p>The D latch introduces a clock <code>C</code>, which ticks by the slowest propogation speed in the circuit. <code>C</code> controls when input data <code>D</code> can change output <code>Q+</code>. When <code>C</code> is active, the D latch is <strong>latching</strong> and <code>Q+</code> will change it&#39;s data according to <code>D</code>. When <code>C</code> is inactive, the D latch is <strong>storing</strong>. When storing, as long as <code>C</code> is inactive, <code>Q+</code> will not change regardless of <code>D</code>.</p>
<img src="./images3823/7.png" alt="">
<img src="./images3823/8.png" alt="">
<p>An issue with D latches is that the value changes every time <code>C</code> is active, which makes it unable to truly store data. To combat this, <strong>flip-flops or edge-triggered latches (FF latches for notes)</strong> are used.</p>
<p>FF latches only change when <code>C</code> is on the rising edge or it is being turned on, and won&#39;t respond to anything else. To measure if the <code>C</code> is on it&#39;s rising edge, three <code>not</code> gates leaving the <code>C</code> are connected to an <code>and</code> gate, and the <code>C</code> is directly connected to the other input of the and gate. The <code>and</code> gate is called the <code>Trigger (T)</code>.  The reason why this works is because there is an extremely small amount of delay between an input and a result, so the three <code>not</code> gates take advantage of that delay to capture the rising edge of <code>C</code>. Besides that the FF latch works very similarly to the D latch.</p>
<img src="./images3823/9.png" alt="">
<p>A register is a group of flipflop circuits where each stores one bit. (Same registers as assembly)</p>
<p>All of the flipflops are controlled by the same clock.</p>
<p>In assembly, we have 32 general purpose registers all controlled by one clock that make one <strong>register file</strong> (see image for what a register file looks like)</p>
<p>Each register file has 2 <strong>read ports</strong> and 1 <strong>write port</strong>. 
The write port has three inputs. <code>RegDataW</code> for the actual data input, <code>WriteReg</code> for where to write the data, and <code>RegWrite</code> which will determine if the data should be written or not.</p>
<p>The read ports have two register numbers <code>ReadReg1</code> and <code>ReadReg2</code> are selectors for two different multiplexers which, then sends data to <code>RegData1</code> and <code>RegData2</code> respectively.</p>
<p>Writing Data is sequential because it uses a clock. Reading data is combinational because of the multiplexers.</p>
<img src="./images3823/10.png" alt="">
<img src="./images3823/11.png" alt="">
<p>Random Access Memory (RAM) aka memory uses sequential logic to store data. RAM has three buses, control, data, and address. Unlike the other two busses which are <strong>unidirectional</strong> (only 1 way the input can move), the data bus is <strong>bidirectional</strong>, which means it can only send <em>or</em> read data, not both simultaneously. The address bus will contain the memory address. The data bus will contain the data either to send or read based on the control bus. The control bus in this course will have a width of two bits and will indicate whether to read or write data using the data bus.</p>
<p>For more info on RAM check out <a href="./1.html">chapter 1</a>'s RAM section.</p>
<img src="./images3823/12.png" alt="">
<h2 id="3-2-assembly-machine-code">3.2 Assembly --&gt; Machine Code</h2>
<p><strong>encoding</strong> is the process of turning assembly into binary.</p>
<p>All ARMv8 encodings (not mandatory): <a href="https://developer.arm.com/documentation/ddi0602/2022-03/Base-Instructions">https://developer.arm.com/documentation/ddi0602/2022-03/Base-Instructions</a></p>
<p>Each arm assembly instruction has 4 bytes (32 bits), and about 2 fields. The leading bits are <strong>opcode</strong> which is used to determine the mnemonic/instruction. The rest of the bits are used for operands such as read/write numbers, and addresses.</p>
<h3 id="3-1-2-arithmetic-and-logical-instructions">3.1.2 Arithmetic and Logical instructions</h3>
<p>There is some patterns to the opcode in instructions, such as if the 30th bit is active, then subtraction will occur, and addition otherwise, and the 29th bit is used to determine whether or not to select condition codes.</p>
<p>When handling registers, bits 15--&gt;10 will always be <code>111000</code> for this course.</p>
<img src="./images3823/13.png" alt="">
<p>When handing instructions with immedietes instead of registers, bits 20--&gt;10 are now used to represent the immediate/number. Besides that handling immediatesis near identical to handling registers.</p>
<p>Do note that the same instructions have different opcodes, from when handling registers, see the image attached for the proper instructions for handling immediates.</p>
<img src="./images3823/14.png" alt="">
<p>When handling branching, the <code>imm11</code> section that is bits 20 through 10 is the label address of the branch - address of the branching instruction</p>
<p>The 4th through 0th bit for CBZ has <code>RT</code> in it, the target register is the register you are comparing to 0.</p>
<img src="./images3823/15.png" alt="">
<h1 id="3-3-single-cycle-datapth">3.3 Single Cycle Datapth</h1>
<h2 id="notation">Notation</h2>
<p><code>R[x] = 64-bit data inside register x</code>
<code>M[a] = data at an address a inside memory</code>
<code>D[a:b] = multibit data D, from bit a to b (inclusive)</code></p>
<p>R[0][5:2] = 2nd to 5th bit in register <code>X0</code>
M[R[1]][31:0] = data at an address indicated by the data in <code>X1</code></p>
<p>if-else statements follow the format of <code>(truecase) if (condition) else (falsecase)</code>with true and false cases being whether the condition is true or not.</p>
<p>if-else statements can be nested as well, following the form <code>(true case) if (condition) else (ifelse true case) if (ifelse condition) else (false condition)</code></p>
<p>Blue lines transfer <strong>control signals</strong> which are usually 1 bit of data, but can be more, used to tell the CPU what operations to perform</p>
<p>Black lines transfer <strong>data signals</strong> which sends data such as operands, they are usually groups of parallel lines/buses where each line transfers 1 bit and they do so simultaneously.</p>
<p>attached is a <strong>single cycle data path</strong>, it a simplified and inefficient version but shows the key concepts of designing a processor</p>
<p>note instruction and data memory are both the same memory and are only seperate for illustration, instruction goes to <code>.text</code> and data goes to either <code>.data</code>, <code>.bss</code>, or the stack area</p>
<p>the process of each instruction takes only 1 clock cycle</p>
<img src="./images3823/16.png" alt="">

</main>
  </body>
</html>