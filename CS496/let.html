<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS Notes</title>
  </head>
  <body>
    <main>
        <h1 id="3-simple-functional-languages">3 Simple Functional Languages</h1>
<h2 id="3-1-let">3.1 Let</h2>
<p><strong>Concrete Syntax</strong></p>
<p> ⟨Expression⟩ ::= ⟨Number⟩<br>
 ⟨Expression⟩ ::= ⟨Identifier⟩<br>
 ⟨Expression⟩ ::= ⟨Expression⟩⟨BOp⟩⟨Expression⟩<br>
 ⟨Expression⟩ ::= zero?(⟨Expression⟩)<br>
 ⟨Expression⟩ ::= if⟨Expression⟩then⟨Expression⟩else⟨Expression⟩<br>
 ⟨Expression⟩ ::= let⟨Identifier⟩=⟨Expression⟩in⟨Expression⟩<br>
 ⟨Expression⟩ ::= (⟨Expression⟩)<br>
 ⟨BOp⟩ ::= +|-|*|/</p>
<p>Note that the terminals generated by the <code>&lt;Identifier&gt;</code> non terminal are left unspecified. These are sequences of symbols including lowercase and uppercase English letters, numbers, and spaces.</p>
<p><strong>Abstract Syntax</strong></p>
<p>Let has the following abstract syntax. (fuck discord for not letting me codeblock this 1 lol)
type expr = <br>
  | Int of int<br>
  | Var of string<br>
  | Add of expr*expr<br>
  | Sub of expr*expr<br>
  | Mul of expr*expr<br>
  | Div of expr*expr<br>
  | IsZero of expr<br>
  | ITE of expr*expr*expr<br>
  | Let of string*expr*expr</p>
<p><strong>Environments</strong></p>
<p>Consider the LET expression <code>x+2</code>, <code>x</code> is an <strong>identifier</strong>. This expression can&#39;t be evaluated because it is incomplete. We can only evaluate it once we are given the value assigned to x. In LET expressions require an assignment of values to identifiers. These assignments are called <strong>environments</strong>.</p>
<p>The interpreters developed in this course are known as <strong>environment-based interpreters</strong> instead of <strong>substitution-based interpreters</strong>.</p>
<p>In substitution-based interpreters, values are directly substituted instead of recording and looking them up in environments.</p>
<p>An environment is a partial function from the set of identifiers to the set of expressed values.</p>
<p><strong>Expressed values</strong> (<em>EV</em>) are the set of values that are not errors that are obtained from evaluating expressions.</p>
<p>In ARITH these are integers, in LET these are integers and Booleans.</p>
<p><em>EV</em> := <em>Z</em> U <em>B</em>
<em>B</em> represents the set of all booleans {true, false}
The set of all environments <em>ENV</em> is
<em>ENV</em> := <em>ID</em> ⇀ <em>EV</em>
where <em>ID</em> is the set of all identifiers generated by the non-terminal <code>&lt;Identifier&gt;</code></p>
<p>Use <em>p</em> and <em>p&#39;</em> to denote environments
ex: <em>p</em> = {<em>x</em>:=1, <em>y</em>:=2, <em>z</em>:=true} will assign 1 to <em>x</em>, 2 to <em>y</em>, and true to <em>z</em>
<em>p</em>(<em>id</em>) will get the value for the identifier <em>id</em>, ex: p(x) is 1</p>
<p><strong>Interpreter</strong></p>
<p>Specification</p>
<p>The evaluation of an ARITH expression produces a result that is either an int or error.</p>
<p>In LET it is also possible to get a boolean.</p>
<p>The set of possible results for LET is
 <em>R</em> := <em>EV</em> U {<em>error</em>}</p>
<p>Evaluation judgements have also been updated to include an environment and are now structured as</p>
<p><em>e</em>, <em>p</em> ⇓ <em>r</em>
&quot;evaluation of expression <em>e</em> under environment <em>p</em> produces result <em>r</em>&quot;</p>
<p>The rules are in 3.1 (below), and the last 4 are for error generation, the first 8 are non-error evaluation, and the rules for error propagation are omitted. </p>
<p>Rule EInt is the same as in ARITH except that the judgement has an environment (irrelivant for this rule)</p>
<p>Rule EVar looks up a variable in the environemnt</p>
<p>Rule EvarErr returns an error if the identifier can&#39;t be found in the env.</p>
<p>Addition subtraction and multiplication are similar to division and omitted.</p>
<p>The notation <em>p</em> ⊕ {<em>id</em> := <em>w</em>} in ELet represents the environment that maps expressed value <em>w</em> to identifier <em>id</em> and behaves as <em>p</em> on all other identifiers.</p>
<p><strong>Implementation Attempt 1</strong></p>
<p>Before implementing the evaluator, the expressed values and environments must be implemented. Environments can be implemented as functions, association lists, hash tables, variant types, etc., but for us we are using variant types.</p>
<p>Here is the code for the environment</p>
<pre><code class="lang-ocaml">
 <span class="hljs-keyword">let</span> empty_env : <span class="hljs-built_in">unit</span>-&gt; env =
   <span class="hljs-keyword">fun</span> <span class="hljs-literal">()</span>-&gt; <span class="hljs-type">EmptyEnv</span>
 <span class="hljs-keyword">let</span> extend_env : env-&gt; <span class="hljs-built_in">string</span>-&gt; exp_val-&gt; env =
   <span class="hljs-keyword">fun</span> env id v-&gt; <span class="hljs-type">ExtendEnv</span>(id,v,env)
 <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> apply_env : <span class="hljs-built_in">string</span>-&gt; env-&gt; exp_val result =
   <span class="hljs-keyword">fun</span> id env-&gt;
   <span class="hljs-keyword">match</span> env <span class="hljs-keyword">with</span>
   | <span class="hljs-type">EmptyEnv</span>-&gt; error (id^<span class="hljs-string">" not found!"</span>)
   | <span class="hljs-type">ExtendEnv</span>(v,ev,tail)-&gt;
     <span class="hljs-keyword">if</span> id=v
     <span class="hljs-keyword">then</span> return ev
     <span class="hljs-keyword">else</span> apply_env id tail
</code></pre>
<p>Note <code>apply_env en</code> has <code>exp_val result</code> as it&#39;s return type because it can return an error if not found in <code>en</code> If there is a value found, it will be wrapped in an <code>Ok</code> constructor.</p>
        <img src="./images4963/1.png" alt="">
<p>There are also now functions following this form</p>
<pre><code class="lang-ocaml"><span class="hljs-keyword">let</span> int_of_numVal : exp_val-&gt; int result =
  <span class="hljs-keyword">fun</span> ev-&gt;
   <span class="hljs-keyword">match</span> ev <span class="hljs-built_in">with</span>
   | <span class="hljs-type">NumVal</span> n-&gt; <span class="hljs-keyword">return</span> n
   | <span class="hljs-type">_</span>-&gt; error <span class="hljs-string">"Expected a number!"</span>
</code></pre>
<p>All they do is verify if the <code>exp_val</code> passed in is of type <code>numVal</code>, and if so return it&#39;s form in ocaml&#39;s typing rather than let&#39;s typing. Otherwise throw an error.</p>
<p>Here are some examples of our interpreter, <em>note i skipped the interpreter code because this is the preliminary implementation, the output will not change but the code will, so i will attach the final code later on</em></p>
<pre><code class="lang-ocaml"><span class="hljs-comment"># interp "</span>
 <span class="hljs-keyword">let</span> <span class="hljs-attr">x=2</span>
 <span class="hljs-keyword">in</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">y=3</span>
 <span class="hljs-keyword">in</span> x+y<span class="hljs-string">";;
- : exp_val Ds.result = Ok (NumVal 5)

utop # interp "</span>
 <span class="hljs-keyword">let</span> <span class="hljs-attr">x=2</span>
 <span class="hljs-keyword">in</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">y=0</span>
 <span class="hljs-keyword">in</span> x+(x/y)<span class="hljs-string">";;
- : exp_val Ds.result = Error "</span>Division by zero<span class="hljs-string">"</span>
</code></pre>
<p>Note negative numbers must be placed inbetween parentheses <code>(-7)</code> is valid, <code>-7</code> is not.</p>
<p>In ARITH only 1 error could be generated and then propagated (div by 0), in LET there are 4 (div by 0, id not found, expected a number, and expected a bool)</p>
<p><strong>Weaving Environments</strong></p>
<p>Now lets add extra features, in the current implementation, <code>en</code>, the parameter for environment is being passed around each time eval_expr is called, even when it is not needed.</p>
<p>By modifying the bind operator, the environment can be handled in just that operation, receiving the environment, and passing its arguments behind the scenes. Though <code>eval_expr</code> still needs an environment to be passed.</p>
<p>Updated error monad&amp;reader</p>
<pre><code class="lang-ocaml"><span class="hljs-keyword">type</span> ’a result = Ok <span class="hljs-keyword">of</span> ’a | Error <span class="hljs-keyword">of</span> string
<span class="hljs-keyword">type</span> ’a ea_result = env-&gt; ’a result

 let <span class="hljs-keyword">return</span> : ’a-&gt; ’a ea_result =
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">v</span></span>-&gt;
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">env</span></span>-&gt; Ok v

 let error : string-&gt; ’a ea_result =
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">s</span></span>-&gt;
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">env</span></span>-&gt; Error s

 let (&gt;&gt;=) : ’a ea_result-&gt; (’a-&gt; ’b ea_result)-&gt; ’b ea_result =
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">c</span></span> f-&gt;
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">env</span></span>-&gt;
   match c env <span class="hljs-keyword">with</span>
     | Error err-&gt; Error err
     | Ok v-&gt; f v env

 let (&gt;&gt;+) : env ea_result-&gt; ’a ea_result-&gt; ’a ea_result =
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">c</span></span> d-&gt;
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">env</span></span>-&gt;
   match c env <span class="hljs-keyword">with</span>
     | Error err-&gt; Error err
     | Ok newenv-&gt; d newenv

 let run : ’a ea_result-&gt; ’a result =
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">c</span></span>-&gt; c EmptyEnv
</code></pre>
<p><code>ea_result</code> stands for environment abstracted result and represents <code>env -&gt; &#39;a</code>, this is done to improve readability.</p>
<p><code>(&gt;&gt;+)</code> can be ignored for now, <code>run</code> will just given an ea_result, will peform the computation and return either an ok value or an error, it will be used in the start of the interpreter.</p>
<p><strong>Implementation Final</strong></p>
<p>the final interpreter for LET can be seen below</p>
<pre><code class="lang-ocaml">
<span class="hljs-keyword">let</span> rec eval_expr : expr-&gt; exp_val ea_result =
  <span class="hljs-keyword">fun</span> e-&gt;
  <span class="hljs-keyword">match</span> e <span class="hljs-built_in">with</span>
   | <span class="hljs-type">Int</span>(n)-&gt; <span class="hljs-keyword">return</span> (NumVal n)
   | <span class="hljs-type">Var</span>(id)-&gt; apply_env id
   | <span class="hljs-type">Div</span>(e1,e2)-&gt; <span class="hljs-comment">(* Add, Sub and Mul are similar and omitted *)</span>
      eval_expr e1 &gt;&gt;=
      int_of_numVal &gt;&gt;= <span class="hljs-keyword">fun</span> n1-&gt;
      eval_expr e2 &gt;&gt;=
      int_of_numVal &gt;&gt;= <span class="hljs-keyword">fun</span> n2-&gt;
      <span class="hljs-keyword">if</span> n2==<span class="hljs-number">0</span>
      <span class="hljs-keyword">then</span> error <span class="hljs-string">"Division by zero"</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> (NumVal (n1/n2))
   | <span class="hljs-type">IsZero</span>(e)-&gt;
     eval_expr e &gt;&gt;=
     int_of_numVal &gt;&gt;= <span class="hljs-keyword">fun</span> n-&gt;
     <span class="hljs-keyword">return</span> (BoolVal (n = <span class="hljs-number">0</span>))
   | <span class="hljs-type">ITE</span>(e1,e2,e3)-&gt;
     eval_expr e1 &gt;&gt;=
     bool_of_boolVal &gt;&gt;= <span class="hljs-keyword">fun</span> b-&gt;
     <span class="hljs-keyword">if</span> b
     <span class="hljs-keyword">then</span> eval_expr e2
     <span class="hljs-keyword">else</span> eval_expr e3
   | <span class="hljs-type">Let</span>(id,def,body)-&gt;
     eval_expr def &gt;&gt;=
     extend_env id &gt;&gt;+
     eval_expr body
   | <span class="hljs-type">_</span>-&gt; failwith <span class="hljs-string">"Not implemented yet!"</span>
  <span class="hljs-keyword">let</span> parse s =
   <span class="hljs-keyword">let</span> lexbuf = Lexing.from_string s <span class="hljs-built_in">in</span>
   <span class="hljs-keyword">let</span> ast = Parser.prog Lexer.read lexbuf <span class="hljs-built_in">in</span>
 ast

 <span class="hljs-keyword">let</span> interp (e:string) : exp_val result =
   <span class="hljs-keyword">let</span> c = e |<span class="hljs-type">&gt; parse</span> |<span class="hljs-type">&gt; eval_expr</span>
   <span class="hljs-built_in">in</span> run c
</code></pre>
<p>There are still 2 problems</p>
<ol>
<li>we need to be able to produce the modified environment resulting from adding the new key-value pair <code>id:=ev</code> into environment <strong>as a result</strong>. This will allow us to pass it when evaluating <code>body</code>.
This is solved by updating <code>extend_env</code> and <code>empty_env</code>, to produce it as a result. <code>extend_env</code> attached below<pre><code class="lang-ocaml">let extend_env : string-&gt; exp_val-&gt; env ea_result =
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">id</span></span> v-&gt;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">env</span></span>-&gt; Ok (ExtendEnv(id,v,env))
</code></pre>
</li>
</ol>
<p>This operation allows us to produce code which is almost correct</p>
<p>The next problem is the code evaluated <code>def</code> under the environment, which is threaded around the interpreter by bind. Then feeds the value into <code>extend_env id</code> to produce an extended environment, the extended environment should be fed into <code>eval_expr</code>, <strong>not</strong> the current one.</p>
<p>This introduces the environment update operation (&gt;&gt;+) seen with the error monad  &amp; reader.</p>
<p><code>c &gt;&gt;+ d</code> will evaluate <code>c env</code>, produce environment <code>newenv</code>, ignore the current environment, and use <code>newenv</code> for d.</p>
<p><em>note the second problem is already solved in the interpreter above</em></p>
<p>Here is some documentation for some expressions which use the <code>ea_result</code> type, including the environment functions.</p>
        <img src="./images4963/2.png" alt="">
        <p><strong>Inspecting the Environment</strong></p>
<p>This is debug
⟨Expression⟩ ::= debug(⟨Expression⟩)</p>
<p>when called it will print the current environment and terminate the program.</p>
<p>In <code>type expr</code> it is added as a case <code>Debug of expr</code></p>
<p>It&#39;s evaluation rule is attached below and here is it&#39;s implementation in the interpreter</p>
<pre><code class="lang-ocaml"> eval_expr : expr-&gt; exp_val ea_result =
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">e</span></span>-&gt;
    match e <span class="hljs-keyword">with</span>
     ...
    | Debug(e)-&gt;
     string_of_env &gt;&gt;= <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">str</span></span>-&gt;
     print_endline str;
     error <span class="hljs-string">"Debug called"</span>
</code></pre>
        <img src="./images4963/3.png" alt="">
    </main>
  </body>
</html>